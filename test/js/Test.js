// Generated by Haxe 4.0.0-preview.5
(function () { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}var Color = function() { };
Color.__name__ = true;
Color.rgbToHsl = function(rgb) {
	var r = rgb.r / 255.0;
	var g = rgb.g / 255.0;
	var b = rgb.b / 255.0;
	var max = Math.max(Math.max(r,g),b);
	var min = Math.min(Math.min(r,g),b);
	var d = max - min;
	var h = 0.0;
	if(d == 0) {
		h = 0.0;
	} else if(max == r) {
		h = (g - b) / d % 6;
	} else if(max == g) {
		h = (b - r) / d + 2;
	} else if(max == b) {
		h = (r - g) / d + 4;
	}
	var l = (min + max) / 2;
	var s = d == 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
	return new HSL((360 + h * 60) % 360,s,l);
};
Color.hslToRgb = function(hsl) {
	var c = (1 - Math.abs(2 * hsl.l - 1)) * hsl.s;
	var hp = hsl.h / 60.0;
	var x = c * (1 - Math.abs(hp % 2 - 1));
	var rgb = null;
	if(isNaN(hsl.h)) {
		rgb = [0.,0,0];
	} else if(hp <= 1) {
		rgb = [c,x,0];
	} else if(hp <= 2) {
		rgb = [x,c,0];
	} else if(hp <= 3) {
		rgb = [0,c,x];
	} else if(hp <= 4) {
		rgb = [0,x,c];
	} else if(hp <= 5) {
		rgb = [x,0,c];
	} else if(hp <= 6) {
		rgb = [c,0,x];
	}
	var m = hsl.l - c * 0.5;
	return new RGB(Math.round(255 * (rgb[0] + m)),Math.round(255 * (rgb[1] + m)),Math.round(255 * (rgb[2] + m)));
};
Color.intToRgb = function(rgb) {
	return new RGB((rgb & 16711680) >> 16,(rgb & 65280) >> 8,rgb & 255);
};
Color.rgbToInt = function(rgb) {
	return rgb.r << 16 | rgb.g << 8 | rgb.b;
};
Color.createGradient = function(rgbStopColors,steps) {
	var gradient = [];
	var _g = 0;
	var _g1 = rgbStopColors.length - 1;
	while(_g < _g1) {
		var i = _g++;
		var rgb = Color.intToRgb(rgbStopColors[i]);
		var startHsl = Color.rgbToHsl(rgb);
		rgb = Color.intToRgb(rgbStopColors[i + 1]);
		var endHsl = Color.rgbToHsl(rgb);
		var offsetStep = 1;
		if(i == 0) {
			offsetStep = 0;
		}
		var currSteps = offsetStep + steps[i];
		var diffH = (endHsl.h - startHsl.h) % 360;
		var shortestH = 2 * diffH % 360 - diffH;
		var stepH = shortestH / (currSteps - 1);
		var stepS = (endHsl.s - startHsl.s) / (currSteps - 1);
		var stepL = (endHsl.l - startHsl.l) / (currSteps - 1);
		var _g2 = offsetStep;
		var _g11 = currSteps;
		while(_g2 < _g11) {
			var step = _g2++;
			var interpolatedHsl = new HSL((360 + startHsl.h + stepH * step) % 360,startHsl.s + stepS * step,startHsl.l + stepL * step);
			rgb = Color.hslToRgb(interpolatedHsl);
			gradient.push(Color.rgbToInt(rgb));
		}
	}
	return gradient;
};
var RGB = function(r,g,b) {
	this.r = r;
	this.g = g;
	this.b = b;
};
RGB.__name__ = true;
var HSL = function(h,s,l) {
	this.h = h;
	this.s = s;
	this.l = l;
};
HSL.__name__ = true;
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var Test = function() { };
Test.__name__ = true;
Test.main = function() {
	var testNum = 0;
	var _g = 0;
	var _g1 = [gif_GifPaletteAnalyzer.AUTO,gif_GifPaletteAnalyzer.NEUQUANT(1),gif_GifPaletteAnalyzer.MEDIANCUT(256,false),gif_GifPaletteAnalyzer.NAIVE256];
	while(_g < _g1.length) {
		var palette_analyzer = _g1[_g];
		++_g;
		var output = new haxe_io_BytesOutput();
		var encoder = new gif_GifEncoder(Test.width,Test.height,0,-1,palette_analyzer);
		var analyzer_desc = Std.string(palette_analyzer) + (palette_analyzer._hx_index == 0 ? " (" + Std.string(encoder.palette_analyzer_enum) + ")" : "");
		var filename = StringTools.replace(StringTools.replace(Test.filenameTemplate,"$0",Std.string(testNum++)),"$1",analyzer_desc);
		console.log("Test.hx:32:","creating \"" + filename + "\" (" + Test.numFrames + " frames) ...");
		console.log("Test.hx:33:","frames size " + Test.width + "x" + Test.height + " ...");
		console.log("Test.hx:35:","using palette analyzer " + analyzer_desc + " ...");
		var t0 = new Date().getTime() / 1000;
		encoder.start(output);
		var _g2 = 0;
		var _g11 = Test.numFrames;
		while(_g2 < _g11) {
			var i = _g2++;
			encoder.add(output,Test.make_frame());
		}
		encoder.commit(output);
		console.log("Test.hx:46:","elapsed " + (new Date().getTime() / 1000 - t0) + "s");
		var bytes = output.getBytes();
		var row = window.document.getElementById("container");
		var wrapperElement = window.document.createElement("span");
		wrapperElement.innerText = analyzer_desc;
		var imageElement = window.document.createElement("img");
		imageElement.src = "data:image/gif;base64," + haxe_crypto_Base64.encode(bytes);
		imageElement.setAttribute("width",Std.string(Test.width * 3));
		row.appendChild(wrapperElement);
		wrapperElement.appendChild(imageElement);
		console.log("Test.hx:65:","done.\n");
	}
};
Test.make_frame = function() {
	var red = 0;
	var green = 0;
	var blue = 0;
	var this1 = new Uint8Array(Test.width * Test.height * 3);
	var pixels = this1;
	var gradientLength = Test.gradient.length;
	var _g = 0;
	var _g1 = Test.width * Test.height;
	while(_g < _g1) {
		var i = _g++;
		var idx = i * gradientLength / (Test.height * Test.width) | 0;
		red = Test.gradient[idx] >> 16 & 255;
		green = Test.gradient[idx] >> 8 & 255;
		blue = Test.gradient[idx] & 255;
		pixels[i * 3] = red & 255;
		pixels[i * 3 + 1] = green & 255;
		pixels[i * 3 + 2] = blue & 255;
	}
	Test.count++;
	var head = Test.gradient.splice(0,gradientLength / Test.numFrames | 0);
	Test.gradient = Test.gradient.concat(head);
	var frame = { delay : Test.delay, flippedY : false, data : pixels};
	return frame;
};
var gif_GifPaletteAnalyzer = $hxEnums["gif.GifPaletteAnalyzer"] = { __ename__ : true, __constructs__ : ["AUTO","NEUQUANT","NAIVE256","MEDIANCUT"]
	,AUTO: {_hx_index:0,__enum__:"gif.GifPaletteAnalyzer",toString:$estr}
	,NEUQUANT: ($_=function(quality) { return {_hx_index:1,quality:quality,__enum__:"gif.GifPaletteAnalyzer",toString:$estr}; },$_.__params__ = ["quality"],$_)
	,NAIVE256: {_hx_index:2,__enum__:"gif.GifPaletteAnalyzer",toString:$estr}
	,MEDIANCUT: ($_=function(maxColors,fastRemap) { return {_hx_index:3,maxColors:maxColors,fastRemap:fastRemap,__enum__:"gif.GifPaletteAnalyzer",toString:$estr}; },$_.__params__ = ["maxColors","fastRemap"],$_)
};
var gif_GifEncoder = function(_frame_width,_frame_height,_framerate,_repeat,_palette_analyzer) {
	if(_repeat == null) {
		_repeat = -1;
	}
	this.palette_analyzer_enum = null;
	this.palette_analyzer = null;
	this.first_frame = true;
	this.started = false;
	this.paletteSize = 7;
	this.colorDepth = 8;
	this.repeat = -1;
	this.framerate = 24;
	this.print = function(v) {
		console.log("../gif/GifEncoder.hx:93:",v);
	};
	this.width = _frame_width;
	this.height = _frame_height;
	this.framerate = _framerate;
	this.repeat = _repeat;
	var pixelsCount = this.width * this.height;
	var tmp;
	if(_palette_analyzer == null) {
		this.palette_analyzer_enum = pixelsCount <= 256 ? gif_GifPaletteAnalyzer.NAIVE256 : gif_GifPaletteAnalyzer.NEUQUANT();
		tmp = pixelsCount <= 256 ? new gif_Naive256() : new gif_NeuQuant();
	} else {
		switch(_palette_analyzer._hx_index) {
		case 0:
			this.palette_analyzer_enum = pixelsCount <= 256 ? gif_GifPaletteAnalyzer.NAIVE256 : gif_GifPaletteAnalyzer.NEUQUANT();
			tmp = pixelsCount <= 256 ? new gif_Naive256() : new gif_NeuQuant();
			break;
		case 1:
			var quality = _palette_analyzer.quality;
			this.palette_analyzer_enum = gif_GifPaletteAnalyzer.NEUQUANT(quality);
			tmp = new gif_NeuQuant(quality);
			break;
		case 2:
			this.palette_analyzer_enum = gif_GifPaletteAnalyzer.NAIVE256;
			tmp = new gif_Naive256();
			break;
		case 3:
			var fastRemap = _palette_analyzer.fastRemap;
			var maxColors = _palette_analyzer.maxColors;
			this.palette_analyzer_enum = gif_GifPaletteAnalyzer.MEDIANCUT(maxColors,fastRemap);
			tmp = new gif_MedianCut(maxColors);
			break;
		}
	}
	this.palette_analyzer = tmp;
	var this1 = new Uint8Array(this.width * this.height * 3);
	this.pixels = this1;
	var this2 = new Uint8Array(this.width * this.height);
	this.indexedPixels = this2;
	this.lzwEncoder = new gif_LzwEncoder();
};
gif_GifEncoder.__name__ = true;
gif_GifEncoder.prototype = {
	start: function(output) {
		if(output == null) {
			this.print("gif: start() output must not be null.");
			return;
		}
		output.writeString("GIF89a");
		this.write_LSD(output);
		this.started = true;
	}
	,add: function(output,frame) {
		if(output == null) {
			this.print("gif: add() output must not be null.");
			return;
		}
		if(!this.started) {
			this.print("gif: add() requires start to be called before adding frames.");
			return;
		}
		var pixels = this.get_pixels(frame);
		this.analyze(pixels);
		if(this.first_frame) {
			this.write_palette(output);
			if(this.repeat != 0) {
				this.write_NetscapeExt(output);
			}
			this.first_frame = false;
		}
		var delay = frame.delay < 0 ? 1.0 / this.framerate : frame.delay;
		this.write_GraphicControlExt(output,delay);
		this.write_image_desc(output,this.first_frame);
		if(!this.first_frame) {
			this.write_palette(output);
		}
		this.write_pixels(output);
	}
	,commit: function(output) {
		if(output == null) {
			this.print("gif: commit() output must be not null.");
			return;
		}
		if(!this.started) {
			this.print("gif: commit() called without start() being called first.");
			return;
		}
		output.writeByte(59);
		output.flush();
		output.close();
		this.started = false;
		this.first_frame = true;
	}
	,get_pixels: function(frame) {
		if(!frame.flippedY) {
			return frame.data;
		}
		var stride = this.width * 3;
		var _g = 0;
		var _g1 = this.height;
		while(_g < _g1) {
			var y = _g++;
			var begin = (this.height - 1 - y) * stride;
			haxe_io_Bytes.ofData(this.pixels.buffer).blit(y * stride,haxe_io_Bytes.ofData(frame.data.buffer),begin,stride);
		}
		return this.pixels;
	}
	,analyze: function(pixels) {
		this.colorTab = this.palette_analyzer.buildPalette(pixels);
		var k = 0;
		var _g = 0;
		var _g1 = this.width * this.height;
		while(_g < _g1) {
			var i = _g++;
			var r = pixels[k++] & 255;
			var g = pixels[k++] & 255;
			var b = pixels[k++] & 255;
			var index = this.palette_analyzer.map(r,g,b);
			this.indexedPixels[i] = index & 255;
		}
	}
	,write_LSD: function(output) {
		output.writeInt16(this.width);
		output.writeInt16(this.height);
		output.writeByte(240 | this.paletteSize);
		output.writeByte(0);
		output.writeByte(0);
	}
	,write_NetscapeExt: function(output) {
		var repeats = this.repeat;
		if(repeats == -1 || repeats < 0) {
			repeats = 0;
		}
		if(repeats == 0) {
			repeats = -1;
		}
		output.writeByte(33);
		output.writeByte(255);
		output.writeByte(11);
		output.writeString("NETSCAPE" + "2.0");
		output.writeByte(3);
		output.writeByte(1);
		output.writeInt16(repeats);
		output.writeByte(0);
	}
	,write_palette: function(output) {
		output.write(haxe_io_Bytes.ofData(this.colorTab.buffer));
		var n = 768 - this.colorTab.length;
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			output.writeByte(0);
		}
	}
	,write_pixels: function(output) {
		this.lzwEncoder.reset(this.indexedPixels,this.colorDepth);
		this.lzwEncoder.encode(output);
	}
	,write_image_desc: function(output,first) {
		output.writeByte(44);
		output.writeInt16(0);
		output.writeInt16(0);
		output.writeInt16(this.width);
		output.writeInt16(this.height);
		if(first) {
			output.writeByte(0);
		} else {
			output.writeByte(128 | this.paletteSize);
		}
	}
	,write_GraphicControlExt: function(output,delay) {
		output.writeByte(33);
		output.writeByte(249);
		output.writeByte(4);
		output.writeByte(0);
		var delay_val = Math.floor(delay * 100);
		output.writeInt16(delay_val);
		output.writeByte(0);
		output.writeByte(0);
	}
};
var gif_IPaletteAnalyzer = function() { };
gif_IPaletteAnalyzer.__name__ = true;
var gif_LzwEncoder = function() {
	this.masks = [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];
	this.cur_bits = 0;
	this.cur_accum = 0;
	this.clear_flg = false;
	this.free_ent = 0;
	this.hsize = gif_LzwEncoder.HSIZE;
	this.maxmaxcode = 1 << gif_LzwEncoder.BITS;
	this.maxbits = gif_LzwEncoder.BITS;
	var this1 = new Int32Array(gif_LzwEncoder.HSIZE);
	this.htab = this1;
	var this2 = new Int32Array(gif_LzwEncoder.HSIZE);
	this.codetab = this2;
	var this3 = new Uint8Array(256);
	this.accum = this3;
};
gif_LzwEncoder.__name__ = true;
gif_LzwEncoder.prototype = {
	reset: function(pixels,color_depth) {
		this.pixAry = pixels;
		this.initCodeSize = Math.max(2,color_depth) | 0;
		this.maxbits = gif_LzwEncoder.BITS;
		this.maxmaxcode = 1 << gif_LzwEncoder.BITS;
		this.hsize = gif_LzwEncoder.HSIZE;
		this.free_ent = 0;
		this.clear_flg = false;
		this.cur_accum = 0;
		this.cur_bits = 0;
	}
	,add: function(c,out) {
		this.accum[this.a_count++] = c & 255;
		if(this.a_count >= 254) {
			this.flush(out);
		}
	}
	,clearTable: function(out) {
		this.resetCodeTable(this.hsize);
		this.free_ent = this.ClearCode + 2;
		this.clear_flg = true;
		this.output(this.ClearCode,out);
	}
	,resetCodeTable: function(hsize) {
		var _g = 0;
		var _g1 = hsize;
		while(_g < _g1) {
			var i = _g++;
			this.htab[i] = -1;
		}
	}
	,compress: function(init_bits,out) {
		var i;
		var c;
		var disp;
		this.g_init_bits = init_bits;
		this.clear_flg = false;
		this.n_bits = this.g_init_bits;
		this.maxcode = (1 << this.n_bits) - 1;
		this.ClearCode = 1 << init_bits - 1;
		this.EOFCode = this.ClearCode + 1;
		this.free_ent = this.ClearCode + 2;
		this.a_count = 0;
		var ent = this.nextPixel();
		var hshift = 0;
		var fcode = this.hsize;
		while(fcode < 65536) {
			++hshift;
			fcode *= 2;
		}
		hshift = 8 - hshift;
		var hsize_reg = this.hsize;
		this.resetCodeTable(hsize_reg);
		this.output(this.ClearCode,out);
		while(true) {
			c = this.nextPixel();
			if(!(c != gif_LzwEncoder.EOF)) {
				break;
			}
			fcode = (c << this.maxbits) + ent;
			i = c << hshift ^ ent;
			if(this.htab[i] == fcode) {
				ent = this.codetab[i];
				continue;
			} else if(this.htab[i] >= 0) {
				disp = hsize_reg - i;
				if(i == 0) {
					disp = 1;
				}
				while(true) {
					if((i -= disp) < 0) {
						i += hsize_reg;
					}
					if(this.htab[i] == fcode) {
						ent = this.codetab[i];
						break;
					}
					if(!(this.htab[i] >= 0)) {
						break;
					}
				}
				if(this.htab[i] == fcode) {
					continue;
				}
			}
			this.output(ent,out);
			ent = c;
			if(this.free_ent < this.maxmaxcode) {
				this.codetab[i] = this.free_ent++ | 0;
				this.htab[i] = fcode | 0;
			} else {
				this.clearTable(out);
			}
		}
		this.output(ent,out);
		this.output(this.EOFCode,out);
	}
	,encode: function(os) {
		os.writeByte(this.initCodeSize);
		this.curPixel = 0;
		this.compress(this.initCodeSize + 1,os);
		os.writeByte(0);
	}
	,flush: function(out) {
		if(this.a_count > 0) {
			out.writeByte(this.a_count);
			out.writeBytes(haxe_io_Bytes.ofData(this.accum.buffer),0,this.a_count);
			this.a_count = 0;
		}
	}
	,maxCode: function(n_bits) {
		return (1 << n_bits) - 1;
	}
	,nextPixel: function() {
		if(this.curPixel == this.pixAry.length) {
			return gif_LzwEncoder.EOF;
		}
		this.curPixel++;
		return this.pixAry[this.curPixel - 1] & 255;
	}
	,output: function(code,out) {
		this.cur_accum &= this.masks[this.cur_bits];
		if(this.cur_bits > 0) {
			this.cur_accum |= code << this.cur_bits;
		} else {
			this.cur_accum = code;
		}
		this.cur_bits += this.n_bits;
		while(this.cur_bits >= 8) {
			this.add(this.cur_accum & 255,out);
			this.cur_accum >>= 8;
			this.cur_bits -= 8;
		}
		if(this.free_ent > this.maxcode || this.clear_flg) {
			if(this.clear_flg) {
				this.maxcode = (1 << (this.n_bits = this.g_init_bits)) - 1;
				this.clear_flg = false;
			} else {
				++this.n_bits;
				if(this.n_bits == this.maxbits) {
					this.maxcode = this.maxmaxcode;
				} else {
					this.maxcode = (1 << this.n_bits) - 1;
				}
			}
		}
		if(code == this.EOFCode) {
			while(this.cur_bits > 0) {
				this.add(this.cur_accum & 255,out);
				this.cur_accum >>= 8;
				this.cur_bits -= 8;
			}
			this.flush(out);
		}
	}
};
var gif_Cube = function() {
};
gif_Cube.__name__ = true;
gif_Cube.prototype = {
	clone: function() {
		var cloned = new gif_Cube();
		cloned.lower = this.lower;
		cloned.upper = this.upper;
		cloned.count = this.count;
		cloned.level = this.upper;
		cloned.rmin = this.rmin;
		cloned.rmax = this.rmax;
		cloned.gmin = this.gmin;
		cloned.gmax = this.gmax;
		cloned.bmin = this.bmin;
		cloned.bmax = this.bmax;
		return cloned;
	}
};
var gif_MedianCut = function(maxColors,fastRemap) {
	if(fastRemap == null) {
		fastRemap = true;
	}
	this.rgb2index = new haxe_ds_IntMap();
	var _g = [];
	var _g1 = 0;
	while(_g1 < 32768) {
		++_g1;
		_g.push(0);
	}
	this.histogram = _g;
	var _g2 = [];
	var _g11 = 0;
	while(_g11 < 32768) {
		++_g11;
		_g2.push(0);
	}
	this.histPtr = _g2;
	var _g3 = [];
	var _g12 = 0;
	while(_g12 < 256) {
		++_g12;
		_g3.push(null);
	}
	this.list = _g3;
	this.maxColors = maxColors != null ? maxColors : 256;
	if(this.maxColors < 1 || this.maxColors > 256) {
		throw new js__$Boot_HaxeError("maxColors must be in the range [1-256]");
	}
	this.fastRemap = fastRemap;
};
gif_MedianCut.__name__ = true;
gif_MedianCut.__interfaces__ = [gif_IPaletteAnalyzer];
gif_MedianCut.RGB15 = function(r,g,b) {
	return (b & -8) << 7 | (g & -8) << 2 | r >> 3;
};
gif_MedianCut.RED = function(x) {
	return (x & 31) << 3 & 255;
};
gif_MedianCut.GREEN = function(x) {
	return (x >> 5 & 255) << 3 & 255;
};
gif_MedianCut.BLUE = function(x) {
	return (x >> 10 & 255) << 3 & 255;
};
gif_MedianCut.RGB24_TO_RGB15 = function(x) {
	var r = (x & 16711680) >> 16;
	var g = (x & 65280) >> 8;
	var b = x & 255;
	return (b & -8) << 7 | (g & -8) << 2 | r >> 3;
};
gif_MedianCut.prototype = {
	buildPalette: function(pixels) {
		var pixelCount = pixels.length / 3 | 0;
		var pixelArray = [];
		var pixel15Array = [];
		var rgb24 = 0;
		var rgb15 = 0;
		var _g = 0;
		var _g1 = pixelCount;
		while(_g < _g1) {
			var i = _g++;
			var pos = i * 3;
			rgb24 = pixels[pos] << 16 | pixels[pos + 1] << 8 | pixels[pos + 2];
			pixelArray[i] = rgb24;
			var x = pixelArray[i];
			var r = (x & 16711680) >> 16;
			var g = (x & 65280) >> 8;
			var b = x & 255;
			rgb15 = (b & -8) << 7 | (g & -8) << 2 | r >> 3;
			this.histogram[rgb15]++;
			pixel15Array[i] = rgb15;
		}
		var _g2 = [];
		var _g3 = 0;
		var _g4 = this.maxColors;
		while(_g3 < _g4) {
			var c = _g3++;
			_g2.push([0,0,0]);
		}
		var colorMap = _g2;
		var numColors = this.medianCut(this.histogram,colorMap,this.maxColors,this.fastRemap);
		this.rgb2index = new haxe_ds_IntMap();
		var _g5 = 0;
		var _g6 = pixelCount;
		while(_g5 < _g6) {
			var i1 = _g5++;
			rgb15 = pixel15Array[i1];
			var colorMapIdx = this.histogram[rgb15];
			this.rgb2index.h[pixelArray[i1]] = colorMapIdx;
		}
		var this1 = new Uint8Array(numColors * 3);
		var colorTab = this1;
		var _g7 = 0;
		var _g8 = numColors;
		while(_g7 < _g8) {
			var i2 = _g7++;
			var pos1 = i2 * 3;
			colorTab[pos1] = colorMap[i2][0] & 255;
			colorTab[pos1 + 1] = colorMap[i2][1] & 255;
			colorTab[pos1 + 2] = colorMap[i2][2] & 255;
		}
		return colorTab;
	}
	,map: function(r,g,b) {
		var rgb = r << 16 | g << 8 | b;
		return this.rgb2index.h[rgb];
	}
	,medianCut: function(hist,colorMap,maxCubes,fastRemap) {
		var lr;
		var lg;
		var lb;
		var median;
		var count;
		var level;
		var splitpos;
		var baseIdx;
		var num;
		var cube = new gif_Cube();
		var cubeA;
		var cubeB;
		var nCubes = 0;
		cube.count = 0;
		var color = 0;
		var _g = 0;
		while(_g < 32768) {
			var i = _g++;
			if(hist[i] != 0) {
				this.histPtr[color++] = i;
				cube.count += hist[i];
			}
		}
		cube.lower = 0;
		cube.upper = color - 1;
		cube.level = 0;
		this.shrink(cube);
		this.list[nCubes++] = cube;
		while(nCubes < maxCubes) {
			level = 255;
			splitpos = -1;
			var _g1 = 0;
			var _g2 = nCubes;
			while(_g1 < _g2) {
				var k = _g1++;
				if(this.list[k].lower != this.list[k].upper) {
					if(this.list[k].level < level) {
						level = this.list[k].level;
						splitpos = k;
					}
				}
			}
			if(splitpos == -1) {
				break;
			}
			cube = this.list[splitpos];
			lr = cube.rmax - cube.rmin;
			lg = cube.gmax - cube.gmin;
			lb = cube.bmax - cube.bmin;
			if(lr >= lg && lr >= lb) {
				this.longdim = 0;
			}
			if(lg >= lr && lg >= lb) {
				this.longdim = 1;
			}
			if(lb >= lr && lb >= lg) {
				this.longdim = 2;
			}
			baseIdx = cube.lower;
			num = cube.upper - cube.lower + 1;
			haxe_ds_ArraySort.rec(this.histPtr,$bind(this,this.compare),baseIdx,num);
			count = 0;
			var i1 = cube.lower;
			while(i1 < cube.upper) {
				if(count >= (cube.count / 2 | 0)) {
					break;
				}
				color = this.histPtr[i1];
				count += hist[color];
				++i1;
			}
			median = i1;
			cubeA = cube.clone();
			cubeA.upper = median - 1;
			cubeA.count = count;
			cubeA.level = cube.level + 1;
			this.shrink(cubeA);
			this.list[splitpos] = cubeA;
			cubeB = cube.clone();
			cubeB.lower = median;
			cubeB.count = cube.count - count;
			cubeB.level = cube.level + 1;
			this.shrink(cubeB);
			this.list[nCubes++] = cubeB;
		}
		this.invMap(hist,colorMap,nCubes,fastRemap);
		return nCubes;
	}
	,shrink: function(cube) {
		var r;
		var g;
		var b;
		var color;
		cube.rmin = 255;
		cube.rmax = 0;
		cube.gmin = 255;
		cube.gmax = 0;
		cube.bmin = 255;
		cube.bmax = 0;
		var _g = cube.lower;
		var _g1 = cube.upper + 1;
		while(_g < _g1) {
			var i = _g++;
			color = this.histPtr[i];
			r = (color & 31) << 3 & 255;
			if(r > cube.rmax) {
				cube.rmax = r;
			}
			if(r < cube.rmin) {
				cube.rmin = r;
			}
			g = (color >> 5 & 255) << 3 & 255;
			if(g > cube.gmax) {
				cube.gmax = g;
			}
			if(g < cube.gmin) {
				cube.gmin = g;
			}
			b = (color >> 10 & 255) << 3 & 255;
			if(b > cube.bmax) {
				cube.bmax = b;
			}
			if(b < cube.bmin) {
				cube.bmin = b;
			}
		}
	}
	,invMap: function(hist,colorMap,nCubes,fastRemap) {
		var r = 0.0;
		var g = 0.0;
		var b = 0.0;
		var index = 0;
		var color = 0;
		var rsum = 0.0;
		var gsum = 0.0;
		var bsum = 0.0;
		var dr = 0.0;
		var dg = 0.0;
		var db = 0.0;
		var d = 0.0;
		var dmin = 0.0;
		var cube;
		var _g = 0;
		var _g1 = nCubes;
		while(_g < _g1) {
			var k = _g++;
			cube = this.list[k];
			bsum = 0.0;
			gsum = bsum;
			rsum = gsum;
			var _g2 = cube.lower;
			var _g11 = cube.upper + 1;
			while(_g2 < _g11) {
				var i = _g2++;
				color = this.histPtr[i];
				r = (color & 31) << 3 & 255;
				rsum += r * hist[color];
				g = (color >> 5 & 255) << 3 & 255;
				gsum += g * hist[color];
				b = (color >> 10 & 255) << 3 & 255;
				bsum += b * hist[color];
			}
			colorMap[k][0] = rsum / cube.count | 0;
			colorMap[k][1] = gsum / cube.count | 0;
			colorMap[k][2] = bsum / cube.count | 0;
		}
		if(fastRemap) {
			var _g21 = 0;
			var _g3 = nCubes;
			while(_g21 < _g3) {
				var k1 = _g21++;
				cube = this.list[k1];
				var _g22 = cube.lower;
				var _g31 = cube.upper + 1;
				while(_g22 < _g31) {
					var i1 = _g22++;
					color = this.histPtr[i1];
					hist[color] = k1;
				}
			}
		} else {
			var _g23 = 0;
			var _g32 = nCubes;
			while(_g23 < _g32) {
				var k2 = _g23++;
				cube = this.list[k2];
				var _g24 = cube.lower;
				var _g33 = cube.upper + 1;
				while(_g24 < _g33) {
					var i2 = _g24++;
					color = this.histPtr[i2];
					r = (color & 31) << 3 & 255;
					g = (color >> 5 & 255) << 3 & 255;
					b = (color >> 10 & 255) << 3 & 255;
					dmin = Infinity;
					var _g25 = 0;
					var _g34 = nCubes;
					while(_g25 < _g34) {
						var j = _g25++;
						dr = colorMap[j][0] - r;
						dg = colorMap[j][1] - g;
						db = colorMap[j][2] - b;
						d = dr * dr + dg * dg + db * db;
						if(d == 0.0) {
							index = j;
							break;
						} else if(d < dmin) {
							dmin = d;
							index = j;
						}
					}
					hist[color] = index;
				}
			}
		}
		return;
	}
	,compare: function(color1,color2) {
		var C1;
		var C2;
		switch(this.longdim) {
		case 0:
			C1 = (color1 & 31) << 3 & 255;
			C2 = (color2 & 31) << 3 & 255;
			break;
		case 1:
			C1 = (color1 >> 5 & 255) << 3 & 255;
			C2 = (color2 >> 5 & 255) << 3 & 255;
			break;
		case 2:
			C1 = (color2 >> 10 & 255) << 3 & 255;
			C2 = (color2 >> 10 & 255) << 3 & 255;
			break;
		default:
			throw new js__$Boot_HaxeError("Unreacheable");
		}
		return C1 - C2;
	}
};
var gif_Naive256 = function() {
	this.rgb2index = new haxe_ds_IntMap();
};
gif_Naive256.__name__ = true;
gif_Naive256.__interfaces__ = [gif_IPaletteAnalyzer];
gif_Naive256.prototype = {
	buildPalette: function(pixels) {
		this.rgb2index = new haxe_ds_IntMap();
		var index2rgb = [];
		var nextIndex = 0;
		var k = 0;
		var _g = 0;
		var _g1 = pixels.length / 3 | 0;
		while(_g < _g1) {
			var i = _g++;
			var rgb = pixels[k++] << 16 | pixels[k++] << 8 | pixels[k++];
			var index = this.rgb2index.h[rgb];
			if(index == null) {
				index = nextIndex++;
				this.rgb2index.h[rgb] = index;
				index2rgb[index] = rgb;
			}
		}
		var this1 = new Uint8Array(nextIndex * 3);
		var colorTab = this1;
		k = 0;
		if(index2rgb.length > 256) {
			throw new js__$Boot_HaxeError("More than 256 unique colors (" + index2rgb.length + " found)");
		}
		var _g2 = 0;
		while(_g2 < index2rgb.length) {
			var rgb1 = index2rgb[_g2];
			++_g2;
			colorTab[k++] = rgb1 >> 16 & 255 & 255;
			colorTab[k++] = rgb1 >> 8 & 255 & 255;
			colorTab[k++] = rgb1 & 255 & 255;
		}
		return colorTab;
	}
	,map: function(r,g,b) {
		var rgb = r << 16 | g << 8 | b;
		return this.rgb2index.h[rgb];
	}
};
var gif_NeuQuant = function(quality) {
	if(quality == null) {
		quality = 10;
	}
	this.sampleInterval = (quality < 1 ? 1 : quality > 100 ? 100 : quality) | 0;
	var this1 = new Int32Array(256);
	this.netindex = this1;
	var this2 = new Int32Array(256);
	this.bias = this2;
	var this3 = new Int32Array(256);
	this.freq = this3;
	var this4 = new Int32Array(32);
	this.radpower = this4;
	var this5 = new Int32Array(1024);
	this.network = this5;
	var this6 = new Uint8Array(768);
	this.colormap_map = this6;
	var this7 = new Int32Array(256);
	this.colormap_index = this7;
};
gif_NeuQuant.__name__ = true;
gif_NeuQuant.__interfaces__ = [gif_IPaletteAnalyzer];
gif_NeuQuant.clamp = function(value,a,b) {
	if(value < a) {
		return a;
	} else if(value > b) {
		return b;
	} else {
		return value;
	}
};
gif_NeuQuant.prototype = {
	buildPalette: function(pixels) {
		this.reset(pixels,pixels.length,this.sampleInterval);
		return this.process();
	}
	,reset: function(thepic,len,sample) {
		this.thepicture = thepic;
		this.lengthcount = len;
		this.samplefac = sample;
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			var value = this.network[i * 4 + 2] = (i << 12) / 256 | 0 | 0;
			var tmp = (this.network[i * 4 + 1] = value | 0) | 0;
			this.network[i * 4] = tmp;
			this.freq[i] = 256;
			this.bias[i] = 0;
		}
	}
	,colormap: function() {
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			this.colormap_index[this.network[i * 4 + 3]] = i | 0;
		}
		var k = 0;
		var _g1 = 0;
		while(_g1 < 256) {
			var i1 = _g1++;
			var j = this.colormap_index[i1];
			this.colormap_map[k++] = this.network[j * 4] & 255;
			this.colormap_map[k++] = this.network[j * 4 + 1] & 255;
			this.colormap_map[k++] = this.network[j * 4 + 2] & 255;
		}
		return this.colormap_map;
	}
	,inxbuild: function() {
		var j;
		var smallpos;
		var smallval;
		var previouscol = 0;
		var startpos = 0;
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			smallpos = i;
			smallval = this.network[i * 4 + 1];
			var _g1 = i + 1;
			var _g11 = 256;
			while(_g1 < _g11) {
				var j1 = _g1++;
				if(this.network[j1 * 4 + 1] < smallval) {
					smallpos = j1;
					smallval = this.network[j1 * 4 + 1];
				}
			}
			if(i != smallpos) {
				j = this.network[smallpos * 4];
				this.network[smallpos * 4] = this.network[i * 4] | 0;
				this.network[i * 4] = j | 0;
				j = this.network[smallpos * 4 + 1];
				this.network[smallpos * 4 + 1] = this.network[i * 4 + 1] | 0;
				this.network[i * 4 + 1] = j | 0;
				j = this.network[smallpos * 4 + 2];
				this.network[smallpos * 4 + 2] = this.network[i * 4 + 2] | 0;
				this.network[i * 4 + 2] = j | 0;
				j = this.network[smallpos * 4 + 3];
				this.network[smallpos * 4 + 3] = this.network[i * 4 + 3] | 0;
				this.network[i * 4 + 3] = j | 0;
			}
			if(smallval != previouscol) {
				this.netindex[previouscol] = startpos + i >> 1 | 0;
				var _g2 = previouscol + 1;
				var _g3 = smallval;
				while(_g2 < _g3) {
					var j2 = _g2++;
					this.netindex[j2] = i | 0;
				}
				previouscol = smallval;
				startpos = i;
			}
		}
		var maxnetpos = 255;
		this.netindex[previouscol] = startpos + maxnetpos >> 1 | 0;
		var _g12 = previouscol + 1;
		var _g21 = 256;
		while(_g12 < _g21) {
			var j3 = _g12++;
			this.netindex[j3] = maxnetpos | 0;
		}
	}
	,learn: function() {
		var j;
		var b;
		var g;
		var r;
		var step;
		if(this.lengthcount < 1509) {
			this.samplefac = 1;
		}
		this.alphadec = 30 + ((this.samplefac - 1) / 3 | 0);
		var p = this.thepicture;
		var pix = 0;
		var lim = this.lengthcount;
		var samplepixels = this.lengthcount / (3 * this.samplefac) | 0;
		var delta = samplepixels / 100 | 0;
		var alpha = 1024;
		var radius = 2048;
		var rad = radius >> 6;
		if(rad <= 1) {
			rad = 0;
		}
		var _g = 0;
		var _g1 = rad;
		while(_g < _g1) {
			var i = _g++;
			this.radpower[i] = alpha * ((rad * rad - i * i) * 256 / (rad * rad)) | 0 | 0;
		}
		if(this.lengthcount < 1509) {
			step = 3;
		} else if(this.lengthcount % 499 != 0) {
			step = 1497;
		} else if(this.lengthcount % 491 != 0) {
			step = 1473;
		} else if(this.lengthcount % 487 != 0) {
			step = 1461;
		} else {
			step = 1509;
		}
		var i1 = 0;
		while(i1 < samplepixels) {
			b = (p[pix] & 255) << 4;
			g = (p[pix + 1] & 255) << 4;
			r = (p[pix + 2] & 255) << 4;
			j = this.contest(b,g,r);
			this.altersingle(alpha,j,b,g,r);
			if(rad != 0) {
				this.alterneigh(rad,j,b,g,r);
			}
			pix += step;
			if(pix >= lim) {
				pix -= this.lengthcount;
			}
			++i1;
			if(delta == 0) {
				delta = 1;
			}
			if(i1 % delta == 0) {
				alpha -= alpha / this.alphadec | 0;
				radius -= radius / 30 | 0;
				rad = radius >> 6;
				if(rad <= 1) {
					rad = 0;
				}
				var _g2 = 0;
				var _g3 = rad;
				while(_g2 < _g3) {
					var j1 = _g2++;
					this.radpower[j1] = alpha * ((rad * rad - j1 * j1) * 256 / (rad * rad)) | 0 | 0;
				}
			}
		}
	}
	,map: function(r,g,b) {
		var dist;
		var a;
		var bestd = 1000;
		var best = -1;
		var i = this.netindex[g];
		var j = i - 1;
		while(i < 256 || j >= 0) {
			if(i < 256) {
				dist = this.network[i * 4 + 1] - g;
				if(dist >= bestd) {
					i = 256;
				} else {
					if(dist < 0) {
						dist = -dist;
					}
					a = this.network[i * 4] - r;
					if(a < 0) {
						a = -a;
					}
					dist += a;
					if(dist < bestd) {
						a = this.network[i * 4 + 2] - b;
						if(a < 0) {
							a = -a;
						}
						dist += a;
						if(dist < bestd) {
							bestd = dist;
							best = this.network[i * 4 + 3];
						}
					}
					++i;
				}
			}
			if(j >= 0) {
				dist = g - this.network[j * 4 + 1];
				if(dist >= bestd) {
					j = -1;
				} else {
					if(dist < 0) {
						dist = -dist;
					}
					a = this.network[j * 4] - r;
					if(a < 0) {
						a = -a;
					}
					dist += a;
					if(dist < bestd) {
						a = this.network[j * 4 + 2] - b;
						if(a < 0) {
							a = -a;
						}
						dist += a;
						if(dist < bestd) {
							bestd = dist;
							best = this.network[j * 4 + 3];
						}
					}
					--j;
				}
			}
		}
		return best;
	}
	,process: function() {
		this.learn();
		this.unbiasnet();
		this.inxbuild();
		return this.colormap();
	}
	,unbiasnet: function() {
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			var _g1 = i * 4;
			var _g11 = this.network;
			_g11[_g1] = _g11[_g1] >> 4 | 0;
			var _g2 = i * 4 + 1;
			var _g12 = this.network;
			_g12[_g2] = _g12[_g2] >> 4 | 0;
			var _g3 = i * 4 + 2;
			var _g13 = this.network;
			_g13[_g3] = _g13[_g3] >> 4 | 0;
			this.network[i * 4 + 3] = i | 0;
		}
	}
	,alterneigh: function(rad,i,b,g,r) {
		var a;
		var lo = i - rad;
		if(lo < -1) {
			lo = -1;
		}
		var hi = i + rad;
		if(hi > 256) {
			hi = 256;
		}
		var j = i + 1;
		var k = i - 1;
		var m = 1;
		while(j < hi || k > lo) {
			a = this.radpower[m++];
			if(j < hi) {
				var _g = j * 4;
				var _g1 = this.network;
				_g1[_g] = _g1[_g] - (a * (this.network[j * 4] - b) / 262144 | 0) | 0;
				var _g2 = j * 4 + 1;
				var _g11 = this.network;
				_g11[_g2] = _g11[_g2] - (a * (this.network[j * 4 + 1] - g) / 262144 | 0) | 0;
				var _g3 = j * 4 + 2;
				var _g12 = this.network;
				_g12[_g3] = _g12[_g3] - (a * (this.network[j * 4 + 2] - r) / 262144 | 0) | 0;
				++j;
			}
			if(k > lo) {
				var _g4 = k * 4;
				var _g13 = this.network;
				_g13[_g4] = _g13[_g4] - (a * (this.network[k * 4] - b) / 262144 | 0) | 0;
				var _g5 = k * 4 + 1;
				var _g14 = this.network;
				_g14[_g5] = _g14[_g5] - (a * (this.network[k * 4 + 1] - g) / 262144 | 0) | 0;
				var _g6 = k * 4 + 2;
				var _g15 = this.network;
				_g15[_g6] = _g15[_g6] - (a * (this.network[k * 4 + 2] - r) / 262144 | 0) | 0;
				--k;
			}
		}
	}
	,altersingle: function(alpha,i,b,g,r) {
		var _g = i * 4;
		var _g1 = this.network;
		_g1[_g] = _g1[_g] - (alpha * (this.network[i * 4] - b) / 1024 | 0) | 0;
		var _g2 = i * 4 + 1;
		var _g11 = this.network;
		_g11[_g2] = _g11[_g2] - (alpha * (this.network[i * 4 + 1] - g) / 1024 | 0) | 0;
		var _g3 = i * 4 + 2;
		var _g12 = this.network;
		_g12[_g3] = _g12[_g3] - (alpha * (this.network[i * 4 + 2] - r) / 1024 | 0) | 0;
	}
	,make_abs: function(value) {
		var tmp = value >> 31;
		value ^= tmp;
		value += tmp & 1;
		return value;
	}
	,contest: function(b,g,r) {
		var dist;
		var biasdist;
		var betafreq;
		var bestd = 2147483647;
		var bestbiasd = bestd;
		var bestpos = -1;
		var bestbiaspos = bestpos;
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			var i_n = i * 4;
			var b_i = i_n;
			var g_i = i_n + 1;
			var r_i = i_n + 2;
			var b_a = this.network[b_i];
			var g_a = this.network[g_i];
			var r_a = this.network[r_i];
			var value = b_a - b;
			var tmp = value >> 31;
			value ^= tmp;
			value += tmp & 1;
			b_a = value;
			var value1 = g_a - g;
			var tmp1 = value1 >> 31;
			value1 ^= tmp1;
			value1 += tmp1 & 1;
			g_a = value1;
			var value2 = r_a - r;
			var tmp2 = value2 >> 31;
			value2 ^= tmp2;
			value2 += tmp2 & 1;
			r_a = value2;
			dist = b_a + g_a + r_a;
			if(dist < bestd) {
				bestd = dist;
				bestpos = i;
			}
			biasdist = dist - (this.bias[i] >> 12);
			if(biasdist < bestbiasd) {
				bestbiasd = biasdist;
				bestbiaspos = i;
			}
			betafreq = this.freq[i] >> 10;
			var _g1 = i;
			var _g11 = this.freq;
			_g11[_g1] = _g11[_g1] - betafreq | 0;
			var _g2 = i;
			var _g12 = this.bias;
			_g12[_g2] = _g12[_g2] + (betafreq << 10) | 0;
		}
		var _g13 = bestpos;
		var _g21 = this.freq;
		_g21[_g13] = _g21[_g13] + 64 | 0;
		var _g14 = bestpos;
		var _g22 = this.bias;
		_g22[_g14] = _g22[_g14] - 65536 | 0;
		return bestbiaspos;
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i1 = 0;
	while(i1 < s.length) {
		var c1 = s.charCodeAt(i1++);
		if(55296 <= c1 && c1 <= 56319) {
			c1 = c1 - 55232 << 10 | s.charCodeAt(i1++) & 1023;
		}
		if(c1 <= 127) {
			a.push(c1);
		} else if(c1 <= 2047) {
			a.push(192 | c1 >> 6);
			a.push(128 | c1 & 63);
		} else if(c1 <= 65535) {
			a.push(224 | c1 >> 12);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		} else {
			a.push(240 | c1 >> 18);
			a.push(128 | c1 >> 12 & 63);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.prototype = {
	blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c1 = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c1);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_crypto_Base64 = function() { };
haxe_crypto_Base64.__name__ = true;
haxe_crypto_Base64.encode = function(bytes,complement) {
	if(complement == null) {
		complement = true;
	}
	var str = new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(bytes).toString();
	if(complement) {
		switch(bytes.length % 3) {
		case 1:
			str += "==";
			break;
		case 2:
			str += "=";
			break;
		default:
		}
	}
	return str;
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw new js__$Boot_HaxeError("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
haxe_crypto_BaseCode.__name__ = true;
haxe_crypto_BaseCode.prototype = {
	encodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		var size = b.length * 8 / nbits | 0;
		var out = new haxe_io_Bytes(new ArrayBuffer(size + (b.length * 8 % nbits == 0 ? 0 : 1)));
		var buf = 0;
		var curbits = 0;
		var mask = (1 << nbits) - 1;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < nbits) {
				curbits += 8;
				buf <<= 8;
				buf |= b.b[pin++];
			}
			curbits -= nbits;
			out.b[pout++] = base.b[buf >> curbits & mask];
		}
		if(curbits > 0) {
			out.b[pout++] = base.b[buf << nbits - curbits & mask];
		}
		return out;
	}
};
var haxe_ds_ArraySort = function() { };
haxe_ds_ArraySort.__name__ = true;
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g = from + 1;
		var _g1 = to;
		while(_g < _g1) {
			var i = _g++;
			var j = i;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	var new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	if(from == mid || mid == to) {
		return;
	}
	var n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,flush: function() {
	}
	,close: function() {
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeInt16: function(x) {
		if(x < -32768 || x >= 32768) {
			throw new js__$Boot_HaxeError(haxe_io_Error.Overflow);
		}
		this.writeUInt16(x & 65535);
	}
	,writeUInt16: function(x) {
		if(x < 0 || x >= 65536) {
			throw new js__$Boot_HaxeError(haxe_io_Error.Overflow);
		}
		if(this.bigEndian) {
			this.writeByte(x >> 8);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8);
		}
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
haxe_io_BytesOutput.__name__ = true;
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,writeBytes: function(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
});
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if((o instanceof Array)) {
			var l = o.length;
			var i;
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = l;
			while(_g3 < _g11) {
				var i1 = _g3++;
				str += (i1 > 0 ? "," : "") + js_Boot.__string_rec(o[i1],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = (e1 instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = "Date";
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
Test.width = 32;
Test.height = 32;
Test.delay = .25;
Test.numFrames = 8;
Test.gradient = Color.createGradient([16711680,16776960,16711680],[128,128]);
Test.filenameTemplate = "test_0$0 $1.gif";
Test.count = 0;
gif_LzwEncoder.EOF = -1;
gif_LzwEncoder.BITS = 12;
gif_LzwEncoder.HSIZE = 5003;
gif_MedianCut.MAXCOLORS = 256;
gif_MedianCut.HSIZE = 32768;
gif_NeuQuant.netsize = 256;
gif_NeuQuant.prime1 = 499;
gif_NeuQuant.prime2 = 491;
gif_NeuQuant.prime3 = 487;
gif_NeuQuant.prime4 = 503;
gif_NeuQuant.minpicturebytes = 1509;
gif_NeuQuant.netbiasshift = 4;
gif_NeuQuant.ncycles = 100;
gif_NeuQuant.intbiasshift = 16;
gif_NeuQuant.intbias = 65536;
gif_NeuQuant.gammashift = 10;
gif_NeuQuant.gamma = 1024;
gif_NeuQuant.betashift = 10;
gif_NeuQuant.beta = 64;
gif_NeuQuant.betagamma = 65536;
gif_NeuQuant.initrad = 32;
gif_NeuQuant.radiusbiasshift = 6;
gif_NeuQuant.radiusbias = 64;
gif_NeuQuant.initradius = 2048;
gif_NeuQuant.radiusdec = 30;
gif_NeuQuant.alphabiasshift = 10;
gif_NeuQuant.initalpha = 1024;
gif_NeuQuant.radbiasshift = 8;
gif_NeuQuant.radbias = 256;
gif_NeuQuant.alpharadbshift = 18;
gif_NeuQuant.alpharadbias = 262144;
gif_NeuQuant.bestd_init = 2147483647;
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
Test.main();
})();
