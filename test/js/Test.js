// Generated by Haxe 4.0.0-preview.4+724129e62
(function () { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var Test = function() { };
Test.__name__ = true;
Test.main = function() {
	console.log("Test.hx:13:","creating test.gif (" + Test.numFrames + " frames) ...");
	console.log("Test.hx:14:","frames' size " + Test.width + "x" + Test.height + " ...");
	var output = new haxe_io_BytesOutput();
	var palette_analyzer = gif_GifPaletteAnalyzer.AUTO;
	var encoder = new gif_GifEncoder(Test.width,Test.height,1,-1,palette_analyzer);
	var palette_analyzer_enum = palette_analyzer._hx_index == 0 ? " (=> " + Std.string(encoder.palette_analyzer_enum) + ")" : "";
	console.log("Test.hx:21:","using palette analyzer " + Std.string(palette_analyzer) + palette_analyzer_enum + " ...");
	encoder.start(output);
	var _g = 0;
	var _g1 = Test.numFrames;
	while(_g < _g1) {
		var i = _g++;
		encoder.add(output,Test.make_frame());
	}
	encoder.commit(output);
	var bytes = output.getBytes();
	var imageElement = window.document.createElement("img");
	window.document.body.appendChild(imageElement);
	imageElement.src = "data:image/gif;base64," + haxe_crypto_Base64.encode(bytes);
	console.log("Test.hx:42:","done.");
};
Test.make_frame = function() {
	var val = 255;
	var red = Test.count % 3 == 0 ? val : 0;
	var green = Test.count % 3 == 1 ? val : 0;
	var blue = Test.count % 3 == 2 ? val : 0;
	Test.count++;
	var this1 = new Uint8Array(Test.width * Test.height * 3);
	var pixels = this1;
	var _g = 0;
	var _g1 = Test.width * Test.height;
	while(_g < _g1) {
		var i = _g++;
		pixels[i * 3] = red & 255;
		pixels[i * 3 + 1] = green & 255;
		pixels[i * 3 + 2] = blue & 255;
	}
	var frame = { delay : Test.delay, flippedY : false, data : pixels};
	return frame;
};
var gif_GifPaletteAnalyzer = $hxEnums["gif.GifPaletteAnalyzer"] = { __ename__ : true, __constructs__ : ["AUTO","NEUQUANT","NAIVE256"]
	,AUTO: {_hx_index:0,__enum__:"gif.GifPaletteAnalyzer",toString:$estr}
	,NEUQUANT: ($_=function(quality) { return {_hx_index:1,quality:quality,__enum__:"gif.GifPaletteAnalyzer",toString:$estr}; },$_.__params__ = ["quality"],$_)
	,NAIVE256: {_hx_index:2,__enum__:"gif.GifPaletteAnalyzer",toString:$estr}
};
var gif_GifEncoder = function(_frame_width,_frame_height,_framerate,_repeat,_palette_analyzer) {
	if(_repeat == null) {
		_repeat = -1;
	}
	this.palette_analyzer_enum = null;
	this.palette_analyzer = null;
	this.first_frame = true;
	this.started = false;
	this.paletteSize = 7;
	this.colorDepth = 8;
	this.repeat = -1;
	this.framerate = 24;
	this.print = function(v) {
		console.log("../gif/GifEncoder.hx:93:",v);
	};
	this.width = _frame_width;
	this.height = _frame_height;
	this.framerate = _framerate;
	this.repeat = _repeat;
	var pixelsCount = this.width * this.height;
	var tmp;
	if(_palette_analyzer == null) {
		this.palette_analyzer_enum = pixelsCount <= 256 ? gif_GifPaletteAnalyzer.NAIVE256 : gif_GifPaletteAnalyzer.NEUQUANT();
		tmp = pixelsCount <= 256 ? new gif_Naive256() : new gif_NeuQuant();
	} else {
		switch(_palette_analyzer._hx_index) {
		case 0:
			this.palette_analyzer_enum = pixelsCount <= 256 ? gif_GifPaletteAnalyzer.NAIVE256 : gif_GifPaletteAnalyzer.NEUQUANT();
			tmp = pixelsCount <= 256 ? new gif_Naive256() : new gif_NeuQuant();
			break;
		case 1:
			var q = _palette_analyzer.quality;
			this.palette_analyzer_enum = gif_GifPaletteAnalyzer.NEUQUANT(q);
			tmp = new gif_NeuQuant(q);
			break;
		case 2:
			this.palette_analyzer_enum = gif_GifPaletteAnalyzer.NAIVE256;
			tmp = new gif_Naive256();
			break;
		}
	}
	this.palette_analyzer = tmp;
	var _g = [];
	var _g1 = 0;
	while(_g1 < 256) {
		var i = _g1++;
		_g.push(false);
	}
	this.usedEntry = _g;
	var this1 = new Uint8Array(this.width * this.height * 3);
	this.pixels = this1;
	var this2 = new Uint8Array(this.width * this.height);
	this.indexedPixels = this2;
	this.lzwEncoder = new gif_LzwEncoder();
};
gif_GifEncoder.__name__ = true;
gif_GifEncoder.prototype = {
	start: function(output) {
		if(output == null) {
			this.print("gif: start() output must not be null.");
			return;
		}
		output.writeString("GIF89a");
		this.write_LSD(output);
		this.started = true;
	}
	,add: function(output,frame) {
		if(output == null) {
			this.print("gif: add() output must not be null.");
			return;
		}
		if(!this.started) {
			this.print("gif: add() requires start to be called before adding frames.");
			return;
		}
		var pixels = this.get_pixels(frame);
		this.analyze(pixels);
		if(this.first_frame) {
			this.write_palette(output);
			if(this.repeat != 0) {
				this.write_NetscapeExt(output);
			}
			this.first_frame = false;
		}
		var delay = frame.delay < 0 ? 1.0 / this.framerate : frame.delay;
		this.write_GraphicControlExt(output,delay);
		this.write_image_desc(output,this.first_frame);
		if(!this.first_frame) {
			this.write_palette(output);
		}
		this.write_pixels(output);
	}
	,commit: function(output) {
		if(output == null) {
			this.print("gif: commit() output must be not null.");
			return;
		}
		if(!this.started) {
			this.print("gif: commit() called without start() being called first.");
			return;
		}
		output.writeByte(59);
		output.flush();
		output.close();
		this.started = false;
		this.first_frame = true;
	}
	,get_pixels: function(frame) {
		if(!frame.flippedY) {
			return frame.data;
		}
		var stride = this.width * 3;
		var _g = 0;
		var _g1 = this.height;
		while(_g < _g1) {
			var y = _g++;
			var begin = (this.height - 1 - y) * stride;
			haxe_io_Bytes.ofData(this.pixels.buffer).blit(y * stride,haxe_io_Bytes.ofData(frame.data.buffer),begin,stride);
		}
		return this.pixels;
	}
	,analyze: function(pixels) {
		this.colorTab = this.palette_analyzer.analyze(pixels);
		var k = 0;
		var _g = 0;
		var _g1 = this.width * this.height;
		while(_g < _g1) {
			var i = _g++;
			var r = pixels[k++] & 255;
			var g = pixels[k++] & 255;
			var b = pixels[k++] & 255;
			var index = this.palette_analyzer.map(r,g,b);
			this.usedEntry[index] = true;
			this.indexedPixels[i] = index & 255;
		}
	}
	,write_LSD: function(output) {
		output.writeInt16(this.width);
		output.writeInt16(this.height);
		output.writeByte(240 | this.paletteSize);
		output.writeByte(0);
		output.writeByte(0);
	}
	,write_NetscapeExt: function(output) {
		var repeats = this.repeat;
		if(repeats == -1 || repeats < 0) {
			repeats = 0;
		}
		if(repeats == 0) {
			repeats = -1;
		}
		output.writeByte(33);
		output.writeByte(255);
		output.writeByte(11);
		output.writeString("NETSCAPE" + "2.0");
		output.writeByte(3);
		output.writeByte(1);
		output.writeInt16(repeats);
		output.writeByte(0);
	}
	,write_palette: function(output) {
		output.write(haxe_io_Bytes.ofData(this.colorTab.buffer));
		var n = 768 - this.colorTab.length;
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			output.writeByte(0);
		}
	}
	,write_pixels: function(output) {
		this.lzwEncoder.reset(this.indexedPixels,this.colorDepth);
		this.lzwEncoder.encode(output);
	}
	,write_image_desc: function(output,first) {
		output.writeByte(44);
		output.writeInt16(0);
		output.writeInt16(0);
		output.writeInt16(this.width);
		output.writeInt16(this.height);
		if(first) {
			output.writeByte(0);
		} else {
			output.writeByte(128 | this.paletteSize);
		}
	}
	,write_GraphicControlExt: function(output,delay) {
		output.writeByte(33);
		output.writeByte(249);
		output.writeByte(4);
		output.writeByte(0);
		var delay_val = Math.floor(delay * 100);
		output.writeInt16(delay_val);
		output.writeByte(0);
		output.writeByte(0);
	}
};
var gif_IPaletteAnalyzer = function() { };
gif_IPaletteAnalyzer.__name__ = true;
var gif_LzwEncoder = function() {
	this.masks = [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];
	this.cur_bits = 0;
	this.cur_accum = 0;
	this.clear_flg = false;
	this.free_ent = 0;
	this.hsize = gif_LzwEncoder.HSIZE;
	this.maxmaxcode = 1 << gif_LzwEncoder.BITS;
	this.maxbits = gif_LzwEncoder.BITS;
	var this1 = new Int32Array(gif_LzwEncoder.HSIZE);
	this.htab = this1;
	var this2 = new Int32Array(gif_LzwEncoder.HSIZE);
	this.codetab = this2;
	var this3 = new Uint8Array(256);
	this.accum = this3;
};
gif_LzwEncoder.__name__ = true;
gif_LzwEncoder.prototype = {
	reset: function(pixels,color_depth) {
		this.pixAry = pixels;
		this.initCodeSize = Math.max(2,color_depth) | 0;
		this.maxbits = gif_LzwEncoder.BITS;
		this.maxmaxcode = 1 << gif_LzwEncoder.BITS;
		this.hsize = gif_LzwEncoder.HSIZE;
		this.free_ent = 0;
		this.clear_flg = false;
		this.cur_accum = 0;
		this.cur_bits = 0;
	}
	,add: function(c,out) {
		this.accum[this.a_count++] = c & 255;
		if(this.a_count >= 254) {
			this.flush(out);
		}
	}
	,clearTable: function(out) {
		this.resetCodeTable(this.hsize);
		this.free_ent = this.ClearCode + 2;
		this.clear_flg = true;
		this.output(this.ClearCode,out);
	}
	,resetCodeTable: function(hsize) {
		var _g = 0;
		var _g1 = hsize;
		while(_g < _g1) {
			var i = _g++;
			this.htab[i] = -1;
		}
	}
	,compress: function(init_bits,out) {
		var i;
		var c;
		var disp;
		this.g_init_bits = init_bits;
		this.clear_flg = false;
		this.n_bits = this.g_init_bits;
		this.maxcode = (1 << this.n_bits) - 1;
		this.ClearCode = 1 << init_bits - 1;
		this.EOFCode = this.ClearCode + 1;
		this.free_ent = this.ClearCode + 2;
		this.a_count = 0;
		var ent = this.nextPixel();
		var hshift = 0;
		var fcode = this.hsize;
		while(fcode < 65536) {
			++hshift;
			fcode *= 2;
		}
		hshift = 8 - hshift;
		var hsize_reg = this.hsize;
		this.resetCodeTable(hsize_reg);
		this.output(this.ClearCode,out);
		while(true) {
			c = this.nextPixel();
			if(!(c != gif_LzwEncoder.EOF)) {
				break;
			}
			fcode = (c << this.maxbits) + ent;
			i = c << hshift ^ ent;
			if(this.htab[i] == fcode) {
				ent = this.codetab[i];
				continue;
			} else if(this.htab[i] >= 0) {
				disp = hsize_reg - i;
				if(i == 0) {
					disp = 1;
				}
				while(true) {
					if((i -= disp) < 0) {
						i += hsize_reg;
					}
					if(this.htab[i] == fcode) {
						ent = this.codetab[i];
						break;
					}
					if(!(this.htab[i] >= 0)) {
						break;
					}
				}
				if(this.htab[i] == fcode) {
					continue;
				}
			}
			this.output(ent,out);
			ent = c;
			if(this.free_ent < this.maxmaxcode) {
				this.codetab[i] = this.free_ent++ | 0;
				this.htab[i] = fcode | 0;
			} else {
				this.clearTable(out);
			}
		}
		this.output(ent,out);
		this.output(this.EOFCode,out);
	}
	,encode: function(os) {
		os.writeByte(this.initCodeSize);
		this.curPixel = 0;
		this.compress(this.initCodeSize + 1,os);
		os.writeByte(0);
	}
	,flush: function(out) {
		if(this.a_count > 0) {
			out.writeByte(this.a_count);
			out.writeBytes(haxe_io_Bytes.ofData(this.accum.buffer),0,this.a_count);
			this.a_count = 0;
		}
	}
	,maxCode: function(n_bits) {
		return (1 << n_bits) - 1;
	}
	,nextPixel: function() {
		if(this.curPixel == this.pixAry.length) {
			return gif_LzwEncoder.EOF;
		}
		this.curPixel++;
		return this.pixAry[this.curPixel - 1] & 255;
	}
	,output: function(code,out) {
		this.cur_accum &= this.masks[this.cur_bits];
		if(this.cur_bits > 0) {
			this.cur_accum |= code << this.cur_bits;
		} else {
			this.cur_accum = code;
		}
		this.cur_bits += this.n_bits;
		while(this.cur_bits >= 8) {
			this.add(this.cur_accum & 255,out);
			this.cur_accum >>= 8;
			this.cur_bits -= 8;
		}
		if(this.free_ent > this.maxcode || this.clear_flg) {
			if(this.clear_flg) {
				this.maxcode = (1 << (this.n_bits = this.g_init_bits)) - 1;
				this.clear_flg = false;
			} else {
				++this.n_bits;
				if(this.n_bits == this.maxbits) {
					this.maxcode = this.maxmaxcode;
				} else {
					this.maxcode = (1 << this.n_bits) - 1;
				}
			}
		}
		if(code == this.EOFCode) {
			while(this.cur_bits > 0) {
				this.add(this.cur_accum & 255,out);
				this.cur_accum >>= 8;
				this.cur_bits -= 8;
			}
			this.flush(out);
		}
	}
};
var gif_Naive256 = function() {
	this.rgb2index = new haxe_ds_IntMap();
	this.indexedPixels = [];
};
gif_Naive256.__name__ = true;
gif_Naive256.__interfaces__ = [gif_IPaletteAnalyzer];
gif_Naive256.prototype = {
	analyze: function(pixels) {
		this.rgb2index = new haxe_ds_IntMap();
		var index2rgb = [];
		var nextIndex = 0;
		var k = 0;
		var _g = 0;
		var _g1 = pixels.length;
		while(_g < _g1) {
			var i = _g++;
			var rgb = pixels[k++] << 16 | pixels[k++] << 8 | pixels[k++];
			var index = this.rgb2index.h[rgb];
			if(index == null) {
				index = nextIndex++;
				this.rgb2index.h[rgb] = index;
				index2rgb[index] = rgb;
			}
			this.indexedPixels[i] = index;
		}
		var this1 = new Uint8Array(nextIndex * 3);
		var colorTab = this1;
		k = 0;
		var _g2 = 0;
		while(_g2 < index2rgb.length) {
			var rgb1 = index2rgb[_g2];
			++_g2;
			colorTab[k++] = rgb1 >> 16 & 255 & 255;
			colorTab[k++] = rgb1 >> 8 & 255 & 255;
			colorTab[k++] = rgb1 & 255 & 255;
		}
		return colorTab;
	}
	,map: function(r,g,b) {
		var rgb = r << 16 | g << 8 | b;
		return this.rgb2index.h[rgb];
	}
};
var gif_NeuQuant = function(quality) {
	if(quality == null) {
		quality = 10;
	}
	this.sampleInterval = (quality < 1 ? 1 : quality > 100 ? 100 : quality) | 0;
	var this1 = new Int32Array(256);
	this.netindex = this1;
	var this2 = new Int32Array(256);
	this.bias = this2;
	var this3 = new Int32Array(256);
	this.freq = this3;
	var this4 = new Int32Array(32);
	this.radpower = this4;
	var this5 = new Int32Array(1024);
	this.network = this5;
	var this6 = new Uint8Array(768);
	this.colormap_map = this6;
	var this7 = new Int32Array(256);
	this.colormap_index = this7;
};
gif_NeuQuant.__name__ = true;
gif_NeuQuant.__interfaces__ = [gif_IPaletteAnalyzer];
gif_NeuQuant.clamp = function(value,a,b) {
	if(value < a) {
		return a;
	} else if(value > b) {
		return b;
	} else {
		return value;
	}
};
gif_NeuQuant.prototype = {
	analyze: function(pixels) {
		this.reset(pixels,pixels.length,this.sampleInterval);
		return this.process();
	}
	,reset: function(thepic,len,sample) {
		this.thepicture = thepic;
		this.lengthcount = len;
		this.samplefac = sample;
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			var value = this.network[i * 4 + 2] = (i << 12) / 256 | 0 | 0;
			var tmp = (this.network[i * 4 + 1] = value | 0) | 0;
			this.network[i * 4] = tmp;
			this.freq[i] = 256;
			this.bias[i] = 0;
		}
	}
	,colormap: function() {
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			this.colormap_index[this.network[i * 4 + 3]] = i | 0;
		}
		var k = 0;
		var _g1 = 0;
		while(_g1 < 256) {
			var i1 = _g1++;
			var j = this.colormap_index[i1];
			this.colormap_map[k++] = this.network[j * 4] & 255;
			this.colormap_map[k++] = this.network[j * 4 + 1] & 255;
			this.colormap_map[k++] = this.network[j * 4 + 2] & 255;
		}
		return this.colormap_map;
	}
	,inxbuild: function() {
		var i;
		var j;
		var smallpos;
		var smallval;
		var previouscol = 0;
		var startpos = 0;
		var _g = 0;
		while(_g < 256) {
			var i1 = _g++;
			smallpos = i1;
			smallval = this.network[i1 * 4 + 1];
			var _g1 = i1 + 1;
			var _g11 = 256;
			while(_g1 < _g11) {
				var j1 = _g1++;
				if(this.network[j1 * 4 + 1] < smallval) {
					smallpos = j1;
					smallval = this.network[j1 * 4 + 1];
				}
			}
			if(i1 != smallpos) {
				j = this.network[smallpos * 4];
				this.network[smallpos * 4] = this.network[i1 * 4] | 0;
				this.network[i1 * 4] = j | 0;
				j = this.network[smallpos * 4 + 1];
				this.network[smallpos * 4 + 1] = this.network[i1 * 4 + 1] | 0;
				this.network[i1 * 4 + 1] = j | 0;
				j = this.network[smallpos * 4 + 2];
				this.network[smallpos * 4 + 2] = this.network[i1 * 4 + 2] | 0;
				this.network[i1 * 4 + 2] = j | 0;
				j = this.network[smallpos * 4 + 3];
				this.network[smallpos * 4 + 3] = this.network[i1 * 4 + 3] | 0;
				this.network[i1 * 4 + 3] = j | 0;
			}
			if(smallval != previouscol) {
				this.netindex[previouscol] = startpos + i1 >> 1 | 0;
				var _g2 = previouscol + 1;
				var _g3 = smallval;
				while(_g2 < _g3) {
					var j2 = _g2++;
					this.netindex[j2] = i1 | 0;
				}
				previouscol = smallval;
				startpos = i1;
			}
		}
		var maxnetpos = 255;
		this.netindex[previouscol] = startpos + maxnetpos >> 1 | 0;
		var _g12 = previouscol + 1;
		var _g21 = 256;
		while(_g12 < _g21) {
			var j3 = _g12++;
			this.netindex[j3] = maxnetpos | 0;
		}
	}
	,learn: function() {
		var j;
		var b;
		var g;
		var r;
		var step;
		if(this.lengthcount < 1509) {
			this.samplefac = 1;
		}
		this.alphadec = 30 + ((this.samplefac - 1) / 3 | 0);
		var p = this.thepicture;
		var pix = 0;
		var lim = this.lengthcount;
		var samplepixels = this.lengthcount / (3 * this.samplefac) | 0;
		var delta = samplepixels / 100 | 0;
		var alpha = 1024;
		var radius = 2048;
		var rad = radius >> 6;
		if(rad <= 1) {
			rad = 0;
		}
		var _g = 0;
		var _g1 = rad;
		while(_g < _g1) {
			var i = _g++;
			this.radpower[i] = alpha * ((rad * rad - i * i) * 256 / (rad * rad)) | 0 | 0;
		}
		if(this.lengthcount < 1509) {
			step = 3;
		} else if(this.lengthcount % 499 != 0) {
			step = 1497;
		} else if(this.lengthcount % 491 != 0) {
			step = 1473;
		} else if(this.lengthcount % 487 != 0) {
			step = 1461;
		} else {
			step = 1509;
		}
		var i1 = 0;
		while(i1 < samplepixels) {
			b = (p[pix] & 255) << 4;
			g = (p[pix + 1] & 255) << 4;
			r = (p[pix + 2] & 255) << 4;
			j = this.contest(b,g,r);
			this.altersingle(alpha,j,b,g,r);
			if(rad != 0) {
				this.alterneigh(rad,j,b,g,r);
			}
			pix += step;
			if(pix >= lim) {
				pix -= this.lengthcount;
			}
			++i1;
			if(delta == 0) {
				delta = 1;
			}
			if(i1 % delta == 0) {
				alpha -= alpha / this.alphadec | 0;
				radius -= radius / 30 | 0;
				rad = radius >> 6;
				if(rad <= 1) {
					rad = 0;
				}
				var _g2 = 0;
				var _g3 = rad;
				while(_g2 < _g3) {
					var j1 = _g2++;
					this.radpower[j1] = alpha * ((rad * rad - j1 * j1) * 256 / (rad * rad)) | 0 | 0;
				}
			}
		}
	}
	,map: function(b,g,r) {
		var dist;
		var a;
		var bestd = 1000;
		var best = -1;
		var i = this.netindex[g];
		var j = i - 1;
		while(i < 256 || j >= 0) {
			if(i < 256) {
				dist = this.network[i * 4 + 1] - g;
				if(dist >= bestd) {
					i = 256;
				} else {
					if(dist < 0) {
						dist = -dist;
					}
					a = this.network[i * 4] - b;
					if(a < 0) {
						a = -a;
					}
					dist += a;
					if(dist < bestd) {
						a = this.network[i * 4 + 2] - r;
						if(a < 0) {
							a = -a;
						}
						dist += a;
						if(dist < bestd) {
							bestd = dist;
							best = this.network[i * 4 + 3];
						}
					}
					++i;
				}
			}
			if(j >= 0) {
				dist = g - this.network[j * 4 + 1];
				if(dist >= bestd) {
					j = -1;
				} else {
					if(dist < 0) {
						dist = -dist;
					}
					a = this.network[j * 4] - b;
					if(a < 0) {
						a = -a;
					}
					dist += a;
					if(dist < bestd) {
						a = this.network[j * 4 + 2] - r;
						if(a < 0) {
							a = -a;
						}
						dist += a;
						if(dist < bestd) {
							bestd = dist;
							best = this.network[j * 4 + 3];
						}
					}
					--j;
				}
			}
		}
		return best;
	}
	,process: function() {
		this.learn();
		this.unbiasnet();
		this.inxbuild();
		return this.colormap();
	}
	,unbiasnet: function() {
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			var _g1 = i * 4;
			var _g11 = this.network;
			_g11[_g1] = _g11[_g1] >> 4 | 0;
			var _g2 = i * 4 + 1;
			var _g12 = this.network;
			_g12[_g2] = _g12[_g2] >> 4 | 0;
			var _g3 = i * 4 + 2;
			var _g13 = this.network;
			_g13[_g3] = _g13[_g3] >> 4 | 0;
			this.network[i * 4 + 3] = i | 0;
		}
	}
	,alterneigh: function(rad,i,b,g,r) {
		var a;
		var lo = i - rad;
		if(lo < -1) {
			lo = -1;
		}
		var hi = i + rad;
		if(hi > 256) {
			hi = 256;
		}
		var j = i + 1;
		var k = i - 1;
		var m = 1;
		while(j < hi || k > lo) {
			a = this.radpower[m++];
			if(j < hi) {
				var _g = j * 4;
				var _g1 = this.network;
				_g1[_g] = _g1[_g] - (a * (this.network[j * 4] - b) / 262144 | 0) | 0;
				var _g2 = j * 4 + 1;
				var _g11 = this.network;
				_g11[_g2] = _g11[_g2] - (a * (this.network[j * 4 + 1] - g) / 262144 | 0) | 0;
				var _g3 = j * 4 + 2;
				var _g12 = this.network;
				_g12[_g3] = _g12[_g3] - (a * (this.network[j * 4 + 2] - r) / 262144 | 0) | 0;
				++j;
			}
			if(k > lo) {
				var _g4 = k * 4;
				var _g13 = this.network;
				_g13[_g4] = _g13[_g4] - (a * (this.network[k * 4] - b) / 262144 | 0) | 0;
				var _g5 = k * 4 + 1;
				var _g14 = this.network;
				_g14[_g5] = _g14[_g5] - (a * (this.network[k * 4 + 1] - g) / 262144 | 0) | 0;
				var _g6 = k * 4 + 2;
				var _g15 = this.network;
				_g15[_g6] = _g15[_g6] - (a * (this.network[k * 4 + 2] - r) / 262144 | 0) | 0;
				--k;
			}
		}
	}
	,altersingle: function(alpha,i,b,g,r) {
		var _g = i * 4;
		var _g1 = this.network;
		_g1[_g] = _g1[_g] - (alpha * (this.network[i * 4] - b) / 1024 | 0) | 0;
		var _g2 = i * 4 + 1;
		var _g11 = this.network;
		_g11[_g2] = _g11[_g2] - (alpha * (this.network[i * 4 + 1] - g) / 1024 | 0) | 0;
		var _g3 = i * 4 + 2;
		var _g12 = this.network;
		_g12[_g3] = _g12[_g3] - (alpha * (this.network[i * 4 + 2] - r) / 1024 | 0) | 0;
	}
	,make_abs: function(value) {
		var tmp = value >> 31;
		value ^= tmp;
		value += tmp & 1;
		return value;
	}
	,contest: function(b,g,r) {
		var i;
		var dist;
		var a;
		var biasdist;
		var betafreq;
		var bestd = 2147483647;
		var bestbiasd = bestd;
		var bestpos = -1;
		var bestbiaspos = bestpos;
		var _g = 0;
		while(_g < 256) {
			var i1 = _g++;
			var i_n = i1 * 4;
			var b_i = i_n;
			var g_i = i_n + 1;
			var r_i = i_n + 2;
			var b_a = this.network[b_i];
			var g_a = this.network[g_i];
			var r_a = this.network[r_i];
			var value = b_a - b;
			var tmp = value >> 31;
			value ^= tmp;
			value += tmp & 1;
			b_a = value;
			var value1 = g_a - g;
			var tmp1 = value1 >> 31;
			value1 ^= tmp1;
			value1 += tmp1 & 1;
			g_a = value1;
			var value2 = r_a - r;
			var tmp2 = value2 >> 31;
			value2 ^= tmp2;
			value2 += tmp2 & 1;
			r_a = value2;
			dist = b_a + g_a + r_a;
			if(dist < bestd) {
				bestd = dist;
				bestpos = i1;
			}
			biasdist = dist - (this.bias[i1] >> 12);
			if(biasdist < bestbiasd) {
				bestbiasd = biasdist;
				bestbiaspos = i1;
			}
			betafreq = this.freq[i1] >> 10;
			var _g1 = i1;
			var _g11 = this.freq;
			_g11[_g1] = _g11[_g1] - betafreq | 0;
			var _g2 = i1;
			var _g12 = this.bias;
			_g12[_g2] = _g12[_g2] + (betafreq << 10) | 0;
		}
		var _g13 = bestpos;
		var _g21 = this.freq;
		_g21[_g13] = _g21[_g13] + 64 | 0;
		var _g14 = bestpos;
		var _g22 = this.bias;
		_g22[_g14] = _g22[_g14] - 65536 | 0;
		return bestbiaspos;
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i1 = 0;
	while(i1 < s.length) {
		var c1 = s.charCodeAt(i1++);
		if(55296 <= c1 && c1 <= 56319) {
			c1 = c1 - 55232 << 10 | s.charCodeAt(i1++) & 1023;
		}
		if(c1 <= 127) {
			a.push(c1);
		} else if(c1 <= 2047) {
			a.push(192 | c1 >> 6);
			a.push(128 | c1 & 63);
		} else if(c1 <= 65535) {
			a.push(224 | c1 >> 12);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		} else {
			a.push(240 | c1 >> 18);
			a.push(128 | c1 >> 12 & 63);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.prototype = {
	blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					s += String.fromCodePoint((c & 63) << 6 | b[i++] & 127);
				} else if(c < 240) {
					var c2 = b[i++];
					s += String.fromCodePoint((c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c1 = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c1);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_crypto_Base64 = function() { };
haxe_crypto_Base64.__name__ = true;
haxe_crypto_Base64.encode = function(bytes,complement) {
	if(complement == null) {
		complement = true;
	}
	var str = new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(bytes).toString();
	if(complement) {
		switch(bytes.length % 3) {
		case 1:
			str += "==";
			break;
		case 2:
			str += "=";
			break;
		default:
		}
	}
	return str;
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw new js__$Boot_HaxeError("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
haxe_crypto_BaseCode.__name__ = true;
haxe_crypto_BaseCode.prototype = {
	encodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		var size = b.length * 8 / nbits | 0;
		var out = new haxe_io_Bytes(new ArrayBuffer(size + (b.length * 8 % nbits == 0 ? 0 : 1)));
		var buf = 0;
		var curbits = 0;
		var mask = (1 << nbits) - 1;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < nbits) {
				curbits += 8;
				buf <<= 8;
				buf |= b.b[pin++];
			}
			curbits -= nbits;
			out.b[pout++] = base.b[buf >> curbits & mask];
		}
		if(curbits > 0) {
			out.b[pout++] = base.b[buf << nbits - curbits & mask];
		}
		return out;
	}
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,flush: function() {
	}
	,close: function() {
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeInt16: function(x) {
		if(x < -32768 || x >= 32768) {
			throw new js__$Boot_HaxeError(haxe_io_Error.Overflow);
		}
		this.writeUInt16(x & 65535);
	}
	,writeUInt16: function(x) {
		if(x < 0 || x >= 65536) {
			throw new js__$Boot_HaxeError(haxe_io_Error.Overflow);
		}
		if(this.bigEndian) {
			this.writeByte(x >> 8);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8);
		}
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
haxe_io_BytesOutput.__name__ = true;
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,writeBytes: function(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
});
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if((o instanceof Array)) {
			var l = o.length;
			var i;
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = l;
			while(_g3 < _g11) {
				var i1 = _g3++;
				str += (i1 > 0 ? "," : "") + js_Boot.__string_rec(o[i1],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = (e1 instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
Test.width = 32;
Test.height = 32;
Test.delay = 1;
Test.numFrames = 5;
Test.count = 0;
gif_LzwEncoder.EOF = -1;
gif_LzwEncoder.BITS = 12;
gif_LzwEncoder.HSIZE = 5003;
gif_NeuQuant.netsize = 256;
gif_NeuQuant.prime1 = 499;
gif_NeuQuant.prime2 = 491;
gif_NeuQuant.prime3 = 487;
gif_NeuQuant.prime4 = 503;
gif_NeuQuant.minpicturebytes = 1509;
gif_NeuQuant.netbiasshift = 4;
gif_NeuQuant.ncycles = 100;
gif_NeuQuant.intbiasshift = 16;
gif_NeuQuant.intbias = 65536;
gif_NeuQuant.gammashift = 10;
gif_NeuQuant.gamma = 1024;
gif_NeuQuant.betashift = 10;
gif_NeuQuant.beta = 64;
gif_NeuQuant.betagamma = 65536;
gif_NeuQuant.initrad = 32;
gif_NeuQuant.radiusbiasshift = 6;
gif_NeuQuant.radiusbias = 64;
gif_NeuQuant.initradius = 2048;
gif_NeuQuant.radiusdec = 30;
gif_NeuQuant.alphabiasshift = 10;
gif_NeuQuant.initalpha = 1024;
gif_NeuQuant.radbiasshift = 8;
gif_NeuQuant.radbias = 256;
gif_NeuQuant.alpharadbshift = 18;
gif_NeuQuant.alpharadbias = 262144;
gif_NeuQuant.bestd_init = 2147483647;
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
Test.main();
})();
